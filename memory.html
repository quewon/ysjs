<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CMSS | 기억 편집</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body.hover {
            cursor: pointer;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>

    <div class="container">

        <div class="right-column"></div>

        <canvas></canvas>

        <header>
            <a href="index.html"><img class="logomin" src="res/logomin.svg"></a>
        </header>

        <footer>
            <span></span>
            <span>(주) 첨단 메모리 시스템</span>
            <span>|</span>
            <span>문의전화 0310-6700-1515</span>
            <span>|</span>
            <span>무료상담</span>
            <span>|</span>
            <span>(주) 첨단 메모리 시스템</span>
            <span></span>
        </footer>

    </div>
    
</body>

<script>
    const canvas = document.querySelector("canvas");
    const context = canvas.getContext("2d");

    var circle_radius = 0;
    var brush_radius = 0;
    var words = {};

    var colors = ["red", "blue", "yellow", "orange", "purple", "green", "yellowgreen", "orangered", "cyan"];

    class Word {
        word;
        color;

        hovered = false;
        selected = false;

        particles = [];
        particle_radius = 50;

        constructor(word) {
            words[word] = this;

            this.word = word;
            this.color = colors.shift();

            this.particle_radius = Math.random() * 40 + 10;

            this.word_particle = new WordParticle(word);
        }
        
        select() {
            for (let word in words) {
                words[word].deselect();
            }
            this.selected = true;
        }

        deselect() {
            this.selected = false;
        }

        delete() {
            colors.push(this.color);
        }

        createParticle(x, y) {
            new Particle(this.word, x, y)
        }
    }

    class Particle {
        word;
        x;
        y;
        color;

        r = 5;
        outer_r;
        vx = 0;
        vy = 0;

        friction = 1.1;

        active = true;

        constructor(word, x, y) {
            words[word].particles.push(this);

            this.word = word;
            this.color = words[word].color;
            this.outer_r = words[word].particle_radius;

            this.x = x;
            this.y = y;
        }

        update_mouse() {
            if (mouse.right) {
                let dx = mouse.x - this.x;
                let dy = mouse.y - this.y;
                let d = Math.sqrt(dx*dx+dy*dy);
                if (d + this.r <= brush_radius) {
                    this.destroy();
                }
            }
        }

        update() {
            this.update_mouse();

            // friction

            this.vx /= this.friction;
            this.vy /= this.friction;

            // attracted to center

            var cx1 = canvas.width/2 - canvas.width/8;
            var cx2 = canvas.width/2 + canvas.width/8;

            // var cx = canvas.width/2;
            var cy = canvas.height/2;
            // var dx = cx - this.x;
            var dx1 = cx1 - this.x;
            var dx2 = cx2 - this.x;
            var dy = cy - this.y;

            var d1 = Math.sqrt(dx1 * dx1 + dy * dy);
            var d2 = Math.sqrt(dx2 * dx2 + dy * dy);

            if (d1 + this.r <= circle_radius || d2 + this.r <= circle_radius) {

            } else {
                if (d2 > d1) {
                    this.vx += dx1 / circle_radius;
                    this.vy += dy / circle_radius;
                } else {
                    this.vx += dx2 / circle_radius;
                    this.vy += dy / circle_radius;
                }
            }

            // repelled from other particles

            for (let word in words) {
                for (let particle of words[word].particles) {
                    if (particle == this) continue;

                    var dx = particle.x - this.x;
                    var dy = particle.y - this.y;
                    var d = Math.sqrt(dx * dx + dy * dy);

                    if (d > this.outer_r + particle.outer_r) continue;

                    d = Math.max(.01, d);

                    var nx = dx / d;
                    var ny = dy / d;
                    var force = -1;

                    force /= Math.max(d, .001);
                    force *= 20;
                    
                    this.vx += nx * force;
                    this.vy += ny * force;
                }
            }

            // movement

            this.vx += Math.random() - .5;
            this.vy += Math.random() - .5;

            this.x += this.vx;
            this.y += this.vy;
        }

        drawLines() {
            context.lineWidth = 1;
            context.strokeStyle = this.color;

            for (let word in words) {
                for (let particle of words[word].particles) {
                    if (particle == this) continue;
                    if (particle.is_word_particle) continue;

                    var dx = particle.x - this.x;
                    var dy = particle.y - this.y;
                    var d = Math.sqrt(dx * dx + dy * dy);

                    if (d > this.outer_r + particle.outer_r) continue;
                    
                    var nx = dx / d;
                    var ny = dy / d;

                    context.beginPath();
                    context.moveTo(this.x, this.y);
                    context.lineTo(particle.x, particle.y);
                    context.stroke();
                }
            }
        }

        draw() {
            context.fillStyle = this.color;
            context.beginPath();
            context.arc(this.x, this.y, this.r, 0, Math.PI*2);
            context.fill();
        }

        destroy() {
            for (let i=0; i<words[this.word].particles.length; i++) {
                if (words[this.word].particles[i] == this) {
                    words[this.word].particles.splice(i, 1);
                    this.active = false;
                    return;
                }
            }
        }
    }

    class WordParticle extends Particle {
        constructor(word) {
            super(word, Math.random() * canvas.width, Math.random() * canvas.height);

            this.r = 40;
            this.outer_r = 60;
            this.is_word_particle = true;
        }

        drawLines() { }

        update_mouse() {
            let dx = mouse.x - this.x;
            let dy = mouse.y - this.y;
            let d = Math.sqrt(dx*dx+dy*dy);

            if (d < this.r) {
                words[this.word].hovered = true;
                document.body.classList.add("hover");
            } else {
                words[this.word].hovered = false;
            }

            if (mouse.down && words[this.word].hovered) {
                words[this.word].select();
            }
        }

        draw() {
            this.r = 40 + words[this.word].particles.length/2;
            this.outer_r = 60 + words[this.word].particles.length/2;

            if (words[this.word].selected) {
                context.shadowBlur = 50;
                context.shadowColor = this.color;
            }

            context.fillStyle = this.color;
            context.beginPath();
            context.arc(this.x, this.y, this.r, 0, Math.PI*2);
            context.fill();

            if (words[this.word].selected) {
                context.shadowBlur = 0;
            }

            context.fillStyle = this.color=="yellow" ? "black" : "white";
            context.textBaseline = "middle";
            context.textAlign = "center";
            context.font = "30px sans-serif";
            context.fillText(this.word, this.x, this.y);
        }
    }

    window.onload = function() {
        window.onresize();

        new Word("상실");
        new Word("희망");
        new Word("사랑");
        new Word("의지");
        new Word("좌절");

        words["상실"].select();

        var wordsarray = Object.keys(words);
        for (let i=0; i<100; i++) {
            new Particle(
                wordsarray[ Math.random() * wordsarray.length | 0 ],
                Math.random() * canvas.width,
                Math.random() * canvas.height
            );
        }

        draw();
    }

    window.onresize = function() {
        canvas.width = window.innerWidth * window.devicePixelRatio;
        canvas.height = window.innerHeight * window.devicePixelRatio;
        canvas.style.width = window.innerWidth + "px";
        canvas.style.height = window.innerHeight + "px";

        circle_radius = Math.min(canvas.width, canvas.height)/2 * .7;
        brush_radius = circle_radius / 5;
    }

    var mouse = {
        down: false,
        x: 0,
        y: 0
    }

    canvas.addEventListener("mousemove", (e) => {
        mouse.x = e.pageX * window.devicePixelRatio;
        mouse.y = e.pageY * window.devicePixelRatio;
    });

    canvas.addEventListener("mousedown", (e) => {
        mouse.down = true;
    });

    canvas.addEventListener("mouseup", (e) => {
        mouse.down = false;
        mouse.right = false;
    });

    canvas.addEventListener("blur", (e) => {
        mouse.down = false;
        mouse.right = false;
    });

    canvas.addEventListener("contextmenu", (e) => {
        mouse.right = true;
        e.preventDefault();
    })

    function draw() {
        document.body.classList.remove("hover");

        context.resetTransform();
        context.clearRect(0, 0, canvas.width, canvas.height);

        context.lineWidth = 2;
        context.strokeStyle = "lightgray";
        context.beginPath();
        context.arc(mouse.x, mouse.y, brush_radius, 0, Math.PI*2);
        context.stroke();

        draw_particles();

        requestAnimationFrame(draw);
    }

    function draw_particles() {
        for (let word in words) {
            for (let particle of words[word].particles) {
                particle.update();
                particle.drawLines();
            }
            for (let particle of words[word].particles) {
                particle.draw();
            }
        }

        if (mouse.down && !mouse.right && !document.body.classList.contains("hover")) {
            for (let word in words) {
                if (words[word].selected) {
                    let r = brush_radius * Math.sqrt(Math.random());
                    let theta = Math.random() * Math.PI * 2;
                    words[word].createParticle(
                        mouse.x + r * Math.cos(theta),
                        mouse.y + r * Math.sin(theta)
                    );
                }
            }
        }
    }

    function lerp( a, b, alpha ) {
        return a + alpha * ( b - a )
    }

</script>

</html>